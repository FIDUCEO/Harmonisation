#!/usr/bin/env python

""" FIDUCEO FCDR harmonisation 
    Author:         Arta Dilo and Peter Harris \ NPL MM
    Date created:   24-01-2017
    Last update:    21-03-2017
    Version:        11.0

Evaluate harmonisation uncertainty for the error structure in har. data 
via Monte Carlo (MC). An MC trial generates data from best estimates of 
harmonisation variables evaluated from regression on simulated data and errors 
generated by respecting the full error structure. Weighted ODR regression is 
performed on the generated data, fit coefficients of MC trials are used to 
evaluate covariance of coefficients that in turn is used to evaluate 
Earth radiance uncertainty from harmonisation. """

from numpy import empty, unique, savetxt, ones, zeros
from optparse import OptionParser
from datetime import datetime as dt
from os.path import join as pjoin
import readHD as rhd
import harFun as har
import unpFun as upf
import visFun as vis
import errStruct as mce 

st = dt.now() # start of script execution

# Set GLOBAL variables 
datadir = "D:\Projects\FIDUCEO\Data\Simulated" # main data folder
mcrdir = pjoin(datadir, 'Results') # folder for MC trials results
#pltdir = pjoin(datadir, 'Graphs') # folder for png images of graphs
newdir = pjoin(datadir, 'newSim_notime') # no-time dependant simulation data

""" Perform multiple-pair regression with ODR """
def multipH(filelist, series):
    
    p = series.nocoefs # number of calibration parameters
    m = series.novars # # number of measured variables
    nos = series.nosensors # number of sensors in the series
    slist = series.sslab # list of sensors in the series
    inCoef = series.preHcoef # input coefficients to simulations
    
    # Create array of initial beta values for the ODR fit
    hsCoef = zeros((nos,p))    

    # Keep the same values as input coefficients in inCoef 
    for sno in range(nos):
        sl = slist[sno]
        hsCoef[sno,:] = inCoef[sl][0:p]
    
    beta0 = hsCoef.flatten('A') # format to ODR input for initial values
    print '\n\nInitial beta values for ODR'
    print beta0
    
    if series.notime: # work with no-time dependant dataset
    
        Im,Hd,Hr,Hs,sp,mutime,corL = rhd.rHData(newdir, filelist) # read netCDF files 
        series.setIm(Im) # set the series index matrix
          
        # perform odr fit with weights from H uncertainties
        HU2 = Hr**2 + Hs**2 # combined random and systematic
        sodr = har.seriesODR(Hd,HU2,beta0,sp,series) # perform odr on sensors' list
        
    else: # work with data in the main data folder
        
        Im,Hd,Hr,Hs,sp,mutime,corL = rhd.rHData(datadir, filelist)    
        series.setIm(Im) # set the series index matrix      
    
        # create ifixb arrays; fix a3 for all series' sensors
        parfix = zeros(nos*p, dtype=int)
        for sidx in range(1,nos):
            parfix[p*sidx:p*sidx+p-1] = 1
        fixb = parfix.tolist() # ifixb ODR parameter
        print '\n\nifixb array for sensors', slist
        print fixb
        
        # create ifixx arrays; fix orbit temperature To for sensors
        varfix = ones(m*2+1, dtype=int)
        varfix[m] = 0 # fix To for 1st sensor 
        varfix[2*m] = 0 # fix To for 2nd sensor 
        fixx = varfix.tolist() # ifixx ODR parameter
        print '\nifixx array', fixx
    
        # perform odr fit with weights from H uncertainties
        HU2 = Hr**2 + Hs**2 # combined random and systematic
        sodr = har.seriesODR(Hd, HU2, beta0, sp, series, fixb, fixx)
        
    return sodr, Hs, mutime # + calib.count uncert matrices

if __name__ == "__main__":

    usage = "usage: %prog filelist time-flag series-label"
    parser = OptionParser(usage=usage)
    (options, args) = parser.parse_args()

    if 4 != len(args):
        parser.error("incorrect number of arguments")

    # 1st argument: list of netCDF files with matchup harmonisation data
    filelist = args[0] # probably input from a text file
    filelist = ["m02_n19.nc","m02_n15.nc","n15_n14.nc","n14_n12.nc"] # temp solution
    
    # 2nd argument boolean: work with no-/ time dependant simulation data
    notime = args[1] # if False work with time dependant data
    if not isinstance(notime, bool): # input is not boolean type
        notime = str(args[1]).lower()
        if notime in ("yes", "true", "t", "1"):
            notime = True
        else:
            notime = False # preferred
    
    # 3rd argument: number of MC trials
    notr = args[2] 
    # 4th argument: series label, not yet used
    series = args[3] 
    
    # Time the execution of the script
    st = dt.now() # start time of script run
    
    # create instance of series class, currently assumed 'avhrr' only
    # TODO: change for different series (label)
    avhrrNx = upf.avhrr(datadir, filelist, notime) 
    
    # perform regression on multiple pairs
    sodr, Hs, mutime = multipH(filelist, avhrrNx)
    
    
    et = dt.now() # end of script run
    exect = (et-st).total_seconds()
    print '\nTime taken for fitting pairs from', filelist
    print (exect/60.), 'minutes\n'
